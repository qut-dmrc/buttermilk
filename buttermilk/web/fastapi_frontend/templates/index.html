{% extends "base.html" %}

{% block title %}Automod qualitative data science dashboard{% endblock %}

{% block content %}
<div class="flex flex-col md:flex-row gap-4" x-data="{
    sessionId: '{{ session_id }}',
    websocket: null,
    messages: [],
    userInput: '',
    progress: { current_step: 0, total_steps: 100, status: 'waiting' },
    requiresConfirmation: false,
    isConnected: false,
    selectedFlow: '',
    selectedCriteria: '',
    selectedRecordId: '',
    isRunning: false,
    error: null,

    // --- WebSocket Connection Logic ---
    connectWebSocket() {
        // Prevent multiple connections
        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
            console.log('WebSocket already connected.');
            return;
        }
        
        // Create WebSocket connection
        this.websocket = new WebSocket(`ws://${window.location.host}/dash/ws/${this.sessionId}`); 

        // Connection opened
        this.websocket.addEventListener('open', (event) => {
            this.isConnected = true;
            console.log('WebSocket connected');
        });

        // Connection closed
        this.websocket.addEventListener('close', (event) => {
            this.isConnected = false;
            this.isRunning = false; // Stop flow if connection drops
            console.log('WebSocket disconnected');
        });

        // Listen for messages
        this.websocket.addEventListener('message', (event) => {
            const data = JSON.parse(event.data);
            console.log('Message from server:', data);

            // Handle different message types
            switch (data.type) {
                case 'chat_message':
                    this.messages.push({
                        content: data.content,
                        timestamp: new Date().toISOString(),
                        agent_info: data.agent_info || {}
                    });
                    this.$nextTick(() => {
                        const container = document.getElementById('messages-container');
                        container.scrollTop = container.scrollHeight;
                    });
                    break;
                case 'script_content':
                    const scriptContent = data.content;
                    const scriptElement = document.createElement('div');
                    scriptElement.innerHTML = scriptContent;
                    document.body.appendChild(scriptElement);
                    break;
                case 'score_update':
                    console.log('Received score update:', data);
                    // Modern structured score handling
                    if (data.agent_id && data.assessor_id && data.score_data) {
                        window.scoreData.addScore(data.agent_id, data.assessor_id, data.score_data);
                    } else {
                        console.error('Invalid score update format:', data);
                    }
                    break;
                case 'progress_update':
                    this.progress = data.progress;
                    break;
                case 'requires_confirmation':
                    this.requiresConfirmation = true;
                    break;
                case 'flow_started':
                    console.log(`Flow ${data.flow} started for record ${data.record_id}`);
                    break;
                case 'flow_state_change':
                    if (data.state === 'TaskProcessingComplete') {
                        this.isRunning = false;
                        this.progress.status = 'completed';
                    } else if (data.state === 'ErrorEvent') {
                        this.isRunning = false;
                        this.progress.status = 'error';
                        this.error = data.details || 'An unspecified error occurred.';
                    }
                    break;
                case 'error':
                    this.error = data.message;
                    this.isRunning = false;
                    this.progress.status = 'error';
                    console.error('Error:', data.message);
                    break;
            }
        });

        // Handle errors
        this.websocket.addEventListener('error', (event) => {
            console.error('WebSocket error:', event);
            this.isConnected = false;
            this.isRunning = false;
            this.error = 'WebSocket connection error.';
        });
    },

    // --- Flow Control Functions ---
    startFlow() {
        if (!this.isConnected) {
            this.connectWebSocket();
        }

        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            console.warn('WebSocket not ready, delaying startFlow slightly.');
            setTimeout(() => this.startFlow(), 500);
            return;
        }

        this.isRunning = true;
        this.messages = [];
        this.error = null;
        this.requiresConfirmation = false;
        this.progress = { current_step: 0, total_steps: 100, status: 'starting' };

        this.websocket.send(JSON.stringify({
            type: 'run_flow',
            flow: this.selectedFlow,
            record_id: this.selectedRecordId,
            criteria: this.selectedCriteria
        }));

        this.$nextTick(() => {
            document.getElementById('messages-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
    },

    sendMessage() {
        if (!this.isConnected || !this.userInput.trim() || !this.isRunning) {
            return;
        }

        this.websocket.send(JSON.stringify({
            type: 'user_input',
            message: this.userInput
        }));

        this.userInput = '';
    },

    confirmFlow() {
        if (!this.isConnected || !this.requiresConfirmation) {
            return;
        }

        this.websocket.send(JSON.stringify({
            type: 'confirm'
        }));

        this.requiresConfirmation = false;
    }

}">
    <!-- Sidebar controls -->
    <div class="w-full md:w-1/4 bg-white shadow rounded-lg p-4">
        <h2 class="text-lg font-semibold mb-4">Configuration</h2>
        
        <div class="mb-4">
            <label for="flow" class="block text-sm font-medium text-gray-700">Choose Flow</label>
            <select 
                id="flow" 
                name="flow" 
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                x-model="selectedFlow"
                hx-get="/dash/api/criteria/"
                hx-include="[name='flow']"
                hx-target="#criteria-container"
                hx-trigger="change"
                hx-indicator=".criteria-loader"
                @change="selectedCriteria = ''; selectedRecordId = ''">
                <option value="">Select a flow</option>
                {% for flow in flow_choices %}
                <option value="{{ flow }}">{{ flow }}</option>
                {% endfor %}
            </select>
        </div>
        
        <div class="mb-4">
            <label for="criteria" class="block text-sm font-medium text-gray-700">Choose Criteria</label>
            <div id="criteria-container">
                <select 
                    id="criteria" 
                    name="criteria" 
                    class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                    x-model="selectedCriteria"
                    disabled
                    x-bind:disabled="!selectedFlow">
                    <option value="">Select criteria</option>
                </select>
                <div class="criteria-loader htmx-indicator">
                    <div class="w-full h-4 bg-gray-200 rounded-sm mt-2 animate-pulse"></div>
                </div>
            </div>
        </div>
        
        <div class="mb-4">
            <label for="record_id" class="block text-sm font-medium text-gray-700">Record ID</label>
            <div id="record-container">
                <select 
                    id="record_id" 
                    name="record_id" 
                    class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                    x-model="selectedRecordId"
                    disabled
                    x-bind:disabled="!selectedFlow"
                    hx-get="/dash/api/records/"
                    hx-include="[name='flow']"
                    hx-target="#record-container"
                    hx-trigger="load delay:500ms, change from:#flow"
                    hx-indicator=".record-loader">
                    <option value="">Select record ID</option>
                </select>
                <div class="record-loader htmx-indicator">
                    <div class="w-full h-4 bg-gray-200 rounded-sm mt-2 animate-pulse"></div>
                </div>
            </div>
        </div>
        
        <div class="mb-4">
            <button 
                class="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
                x-bind:disabled="!selectedFlow || !selectedRecordId || isRunning"
                @click="startFlow()">
                Start Flow
            </button>
        </div>
        
        <div x-show="requiresConfirmation" class="mt-4">
            <button 
                class="w-full bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                @click="confirmFlow()">
                Confirm
            </button>
        </div>
        
        <div class="mt-6">
            <button 
                class="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                x-bind:disabled="!selectedFlow || !selectedCriteria || !selectedRecordId"
                hx-get="/dash/api/history/"
                hx-include="[name='flow'], [name='criteria'], [name='record_id']"
                hx-target="#history-container"
                hx-indicator=".history-loader">
                Load Run History
            </button>
        </div>
    </div>
    
    <!-- Main content area -->
    <div class="w-full md:w-2/3 flex flex-col gap-4">
        <!-- Chat interface -->
        <div class="bg-white shadow rounded-lg p-4 flex-grow max-h-[70vh] flex flex-col">
            <h2 class="text-lg font-semibold mb-4">Agent Chat</h2>
            
            <!-- Messages container -->
            <div class="flex-grow overflow-y-auto p-2 mb-4 bg-gray-50 rounded-md" id="messages-container">
                <template x-if="messages.length === 0">
                    <div class="text-center text-gray-500 py-8">
                        <p>No messages yet. Start a flow to begin the conversation.</p>
                    </div>
                </template>
                <template x-for="(msg, index) in messages" :key="index">
                    <div x-html="msg.content" class="my-2"></div>
                </template>
            </div>
            
            <!-- Input area -->
            <div class="flex space-x-2">
                <input 
                    type="text" 
                    x-model="userInput" 
                    class="flex-grow px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    placeholder="Type your message here..."
                    x-bind:disabled="!isConnected || !isRunning"
                    @keyup.enter="sendMessage()">
                <button 
                    class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
                    x-bind:disabled="!isConnected || !isRunning || userInput.trim() === ''"
                    @click="sendMessage()">
                    Send
                </button>
            </div>
        </div>
        
        <!-- Progress tracker -->
        <div class="bg-white shadow rounded-lg p-4">
            <h2 class="text-lg font-semibold mb-4">Workflow Progress</h2>
            <div class="w-full bg-gray-200 rounded-full h-4">
                <div 
                    class="bg-indigo-600 h-4 rounded-full transition-all duration-500 progress-bar" 
                    x-bind:class="{
                        'bg-green-600': progress.status === 'completed',
                        'bg-red-600': progress.status === 'error',
                        'bg-indigo-600': progress.status !== 'completed' && progress.status !== 'error'
                    }"
                    x-bind:style="'width: ' + (progress.current_step / progress.total_steps * 100) + '%'">
                </div>
            </div>
            <div class="mt-2 text-sm text-gray-600">
                <span x-text="progress.status === 'waiting' ? 'Waiting to start' : progress.status"></span>
                <span x-show="progress.step_name"> - <span x-text="progress.step_name"></span></span>
                <span x-show="progress.role"> (<span x-text="progress.role"></span>)</span>
            </div>
        </div>
        
        <!-- Run history -->
        <div class="bg-white shadow rounded-lg p-4">
            <h2 class="text-lg font-semibold mb-4">Run History</h2>
            <div id="history-container">
                <div class="text-center text-gray-500 py-4">
                    <p>No history loaded. Use the "Load Run History" button to view previous runs.</p>
                </div>
                <div class="history-loader htmx-indicator">
                    <div class="w-full h-20 bg-gray-200 rounded-sm animate-pulse"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Scores panel -->
    <div class="md:block md:w-2/12 bg-white shadow rounded-lg p-2" 
         x-data="{ 
            get scores() { return $store.scores.data; },
       version: 0,
           updateScores() {
             console.log('Current scores:', this.scores);
           } 
         }"
         x-init="$watch('$store.scores.version', (val) => { 
            version = val;
            updateScores(); 
          })">
        <h2 class="text-sm font-semibold mb-2">Scores <button @click="updateScores()" class="text-xs bg-gray-200 px-1 rounded">Debug</button></h2>
        <div id="scores-container" class="overflow-y-auto max-h-[70vh]">
            <template x-if="Object.keys(scores).length === 0">
                <div class="text-center text-gray-500 py-4 text-xs">
                    <p>No scores yet.</p>
                </div>
            </template>
            <template x-for="(agentScores, agentId) in scores" :key="agentId">
                <div class="mb-4 border-b pb-2">
                    <div class="text-xs font-medium text-gray-700 mb-1" x-text="agentId"></div>
                    <div class="flex flex-wrap gap-1">
                        <template x-for="(score, assessorId) in agentScores" :key="assessorId">
                            <div class="tooltip" :title="'Score: ' + score.score_text + ' by ' + score.assessor">
                                <div class="flex items-center">
                                    <span x-text="assessorId.slice(0, 2)" class="text-xs text-gray-500 mr-1"></span>
                                    <span class="w-4 h-4 rounded-full" :style="'background-color:' + score.color"></span>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>

<style>
.tooltip {
    position: relative;
    display: inline-block;
}

.tooltip:hover::after {
    content: attr(title);
    position: absolute;
    left: 0;
    top: 100%;
    z-index: 1;
    background-color: #555;
    color: white;
    text-align: center;
    padding: 5px;
    border-radius: 6px;
    font-size: 0.75rem;
    white-space: nowrap;
}
</style>
{% endblock %}

{% block scripts %}
<script>
    // Configure marked.js with secure defaults
    marked.setOptions({
        breaks: false,  // Add line breaks as <br> elements
        gfm: true,     // Enable GitHub Flavored Markdown
        headerIds: false, // Disable automatic generation of header IDs
        mangle: false,   // Don't mangle email addresses
        sanitize: false, // Modern versions of marked don't support sanitize option
        silent: false,   // Don't ignore errors
        smartLists: true, // Use smarter list behavior
        smartypants: false, // Don't use "smart" typographic punctuation
        xhtml: false     // Don't use XHTML closing tags
    });

    // Use DOMPurify to sanitize HTML if available
    if (typeof DOMPurify !== 'undefined') {
        const originalParse = marked.parse;
        marked.parse = function(src, options) {
            const html = originalParse.call(this, src, options);
            return DOMPurify.sanitize(html);
        };
    }

    // Custom htmx event handlers
    document.body.addEventListener('htmx:afterSwap', function(event) {
        if (window.Alpine) {
            window.Alpine.initTree(event.detail.target);
        }
    });

    document.addEventListener('alpine:init', () => {
        Alpine.store('scores', {
            data: {},
            version: 0 
        });
    });

    // Replace your existing window.scoreData.addScore function
    window.scoreData = {
        scores: {},
        addScore: function(agentId, assessorId, scoreData) {
            if (!this.scores[agentId]) {
                this.scores[agentId] = {};
            }
            this.scores[agentId][assessorId] = scoreData;
            
            // Update Alpine.js data
            Alpine.nextTick(() => {
                Alpine.store('scores').data = {...this.scores};
                Alpine.store('scores').version++; // Increment to trigger reactivity
                console.log('Updated Alpine store with scores:', this.scores);
            });
        }
    };
    
    // Debug WebSocket messages
    const originalSend = WebSocket.prototype.send;
    WebSocket.prototype.send = function(data) {
        console.log('WS SEND:', data);
        return originalSend.call(this, data);
    };
    
  
</script>
{% endblock %}
